# backend/app/services/event_service.py
import logging
from uuid import UUID
from typing import Optional, Dict, Any
from motor.motor_asyncio import AsyncIOMotorDatabase
from datetime import date, datetime  # Ensure datetime is imported if not already

from app.models.event import (
    EventInDB,
    EventType,
)  # Import your Event model and EventType enum

logger = logging.getLogger(__name__)
EVENTS_COLLECTION_NAME = "events"


async def log_event(
    db: AsyncIOMotorDatabase,
    event_type: str,  # Use strings from EventType enum
    user_id: str,
    relevant_date: date,  # The primary date for calendar display
    description: Optional[str] = None,
    related_entity_id: Optional[UUID] = None,
    related_entity_type: Optional[str] = None,
    details: Optional[Dict[str, Any]] = None,
) -> Optional[EventInDB]:
    """
    Creates and stores an event document in the 'events' collection.

    Args:
        db: The Motor database instance.
        event_type: The type of event (e.g., EventType.INVOICE_CREATED).
        user_id: The ID of the user associated with the event.
        relevant_date: The primary date for this event (e.g., invoice issue date, work item date).
        description: A human-readable description.
        related_entity_id: ID of the main entity involved.
        related_entity_type: Type of the main entity.
        details: Additional structured data about the event.

    Returns:
        The created EventInDB object or None if creation failed.
    """
    event_collection = db[EVENTS_COLLECTION_NAME]
    event_timestamp = datetime.utcnow()  # Logged timestamp

    event_data_for_model = {
        "event_type": event_type,
        "user_id": user_id,
        "relevant_date": relevant_date,  # Pass date object directly
        "description": description,
        "related_entity_id": related_entity_id,
        "related_entity_type": related_entity_type,
        "details": details,
        "timestamp": event_timestamp,  # Set timestamp here
        # id will be generated by Pydantic model default_factory
    }

    try:
        event_doc_pydantic = EventInDB(**event_data_for_model)
        # Convert date fields to datetime for MongoDB if EventInDB uses 'date' type for relevant_date
        # and you store dates as datetimes in Mongo.
        insert_data = event_doc_pydantic.model_dump(by_alias=True)

        # If 'relevant_date' in EventInDB is 'date' and you store as datetime in Mongo:
        if isinstance(event_doc_pydantic.relevant_date, date) and not isinstance(
            event_doc_pydantic.relevant_date, datetime
        ):
            from datetime import time, timezone  # Import locally if not at top

            insert_data["relevant_date"] = datetime.combine(
                event_doc_pydantic.relevant_date, time.min, tzinfo=timezone.utc
            )

        result = await event_collection.insert_one(insert_data)
        logger.info(
            f"Logged event: Type='{event_type}', User='{user_id}', RelevantDate='{relevant_date}', ID='{result.inserted_id}'"
        )
        # Fetch and return the created document for confirmation
        created_event_doc = await event_collection.find_one({"_id": result.inserted_id})
        if created_event_doc:
            return EventInDB(**created_event_doc)
        return None  # Should not happen if insert was successful
    except Exception as e:
        logger.error(
            f"Failed to log event: Type='{event_type}', User='{user_id}'. Error: {e}",
            exc_info=True,
        )
        return None
